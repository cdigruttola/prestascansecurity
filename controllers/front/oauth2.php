<?php
/**
 * Copyright 2023 Profileo Group <contact@profileo.com> (https://www.profileo.com/fr/)
 *
 * For questions or comments about this software, contact Maxime Morel-Bailly <security@prestascan.com>
 * List of required attribution notices and acknowledgements for third-party software can be found in the NOTICE file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author    Profileo Group - Complete list of authors and contributors to this software can be found in the AUTHORS file.
 * @copyright Since 2023 Profileo Group <contact@profileo.com> (https://www.profileo.com/fr/)
 * @license   https://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0
 */

class PrestascansecurityOauth2ModuleFrontController extends ModuleFrontController
{

    // Compatibility for PS 1.6
    public $content_only = true;
    // Compatibility for PS 1.6
    public $display_header = false;
    // Compatibility for PS 1.6
    public $display_footer = false;

    public function init()
    {
        // Why using a FrontController for a backoffice only module?
        // The FrontController is used in order to be able to reveive the callback for the oauth authorization as we don't want
        // to send the admin path and admin token to the server.
        // 
        // How do you make sure that the frontoffice controller is only accessible by admin users?
        // Unfortunately, PrestaShop is not allowing to read admin cookies in the frontoffice (FrontController). So we cannot check
        // if the user is an admin based on its cookie. Thus, the workaround here is to use an additional token generated by the Admin
        // side. It will be a GET parameter that will be then compared against the expected token. Check function `isSudoTokenValid`.

        require_once __DIR__."/../../vendor/autoload.php";
    }

    public function initContent()
    {
        // Check our sudo user token
        if (!$this->isSudoTokenValid()) {
            \PrestaScan\Tools::displayErrorAndDie(401, "Token mismatch");
        }

        // Initial login/registration
        if (Tools::getValue('login')) {
            return $this->triggerLogin();
        }

        // Check if we received clients crendentials
        if (Tools::getValue('authorization') && Tools::getValue('clientid') && Tools::getValue('clientsecret')) {
            \PrestaScan\OAuth2\Oauth::saveClientCredentials(Tools::getValue('clientid'), Tools::getValue('clientsecret'));
            // We can now continue with the authorization
            $this->triggerAuthorization();
            exit();
        }

        // The server might return an error.
        // It will die in case of error.
        $this->checkError();

        // If we are here, then we expect the authorization code and the state returned by our oauth server
        $code = Tools::getValue('code');
        $state = Tools::getValue('state');
        if (empty($code) || empty($state)) {
            \PrestaScan\Tools::displayErrorAndDie(500, "Missing parameters code and state.
                There might be an issue with your account.
                Try loggin out and registrer for a new account.");
        }

        // We will compare that the state code received is the same than the state code we sent.
        if (!Context::getContext()->cookie->__isset('psscan_oauth2state')
            || $state !== Context::getContext()->cookie->__get('psscan_oauth2state')) {
            \PrestaScan\Tools::displayErrorAndDie(401, "Invalid state");
        }

        // We can now request a token
        $OAuth = new \PrestaScan\OAuth2\Oauth();
        try {
            // We request a new access token
            $accessToken = $OAuth->getNewAccessTokenFromAuthorizationCode($code);
            // We save this token
            $OAuth->saveTokens($accessToken);

            Context::getContext()->cookie->__unset('psscan_oauth2state');
            Context::getContext()->cookie->__unset('psscan_tokenfc');

            // 1.7 seulement ?
            // https://devdocs.prestashop-project.org/1.7/modules/core-updates/1.6-1.7/
            if (version_compare(_PS_VERSION_, '1.7', '>=')) {
                $this->setTemplate('module:prestascansecurity/views/templates/front/oauth_result.tpl');
            } else {
                $this->setTemplate('oauth_result.tpl');
            }
        } catch (\Exception $exp) {
            // Other exception
            Context::getContext()->cookie->__unset('psscan_oauth2state');
            Context::getContext()->cookie->__unset('psscan_tokenfc');

            // @todo : Manage this error
            die("Exception retriving access token");
        }

    }

    private function triggerLogin()
    {
        // We create a cookie to prove that the request was done by the admin
        // Please note that we called isSudoTokenValid() prior to that to check the token.
        $tokenFC = $this->getTokenFc();
        Context::getContext()->cookie->__set('psscan_tokenfc', $tokenFC);
        Context::getContext()->cookie->write();

        // Force Test Mode
        $localOauth = \Tools::getValue('localoauth') ? true : false;
        Configuration::updateGlobalValue('PRESTASCAN_TEST_MODE_OAUTH', $localOauth);

        $OAuth = new \PrestaScan\OAuth2\Oauth();
        $redirectUrl = \PrestaScan\OAuth2\Oauth::getOauth2RedirectUrl();
        $endpoint = $OAuth->getRegistragionUrl();

        // Retrieve employee data.
        $firstName = \Tools::getValue('firstname');
        $lastName = \Tools::getValue('lastname');
        $email = \Tools::getValue('email');
        $webcrontoken = \Tools::getValue('webcrontoken');
        $psShopUrls = \Tools::getValue('ps_shop_urls');
        $params = [
            'createclient' => true,
            'firstname' => $firstName,
            'lastname' => $lastName,
            'email' => $email,
            'redirect' => $redirectUrl,
            'webcrontoken' => $webcrontoken,
            'ps_shop_urls' => $psShopUrls
        ];

        // Build the query string
        // Example of URL generated here :
        // https://.../generate-user-oauth?createclient=1&firstname=Testeur&lastname=Testeur
        // &email=testeur%40profileo.com&redirect=http%3A%2F%2F127.0.0.1%3A42771%2Fmodule%2Fprestascansecurity%2Foauth2

        $this->context->smarty->assign('registration_url', $endpoint);
        foreach ($params as $key => $aPostParam) {
            $this->context->smarty->assign($key, $aPostParam);
        }
        if (version_compare(_PS_VERSION_, '1.7', '>=')) {
            $this->setTemplate('module:prestascansecurity/views/templates/front/redirect_post.tpl');
        } else {
            $this->setTemplate('redirect_post.tpl');
        }

        return true;
    }

    private function triggerAuthorization()
    {
        $OAuth = new \PrestaScan\OAuth2\Oauth();
        $provider = $OAuth->getProvider(false);

        try {
            // Try to get an access token using the client credentials grant.
            $state = $provider->getState();
            $options = array();
            $options['state'] = $state;
            $authorizationUrl = $provider->getAuthorizationUrl($options);

            // Save the state code (to be checked after redirection)
            Context::getContext()->cookie->__set('psscan_oauth2state', $state);
            Context::getContext()->cookie->write();

            // Redirect the user to the authorization URL.
            header('Location: ' . $authorizationUrl);
            exit();

        } catch (\Exception $e) {
            // Failed to get the access token
            die('Error loading authentication');
        }
    }

    private function isSudoTokenValid()
    {
        // First, we check that the request is comming from our admin. We would either have a token as
        // paramer or a token as cookie (depending if the authorization was already done or not)

        // Our expected token
        $tokenFC = $this->getTokenFc();

        // The provided token
        $tokenParameter = !empty(Tools::getValue('token')) ? Tools::getValue('token') : null;
        $tokenCookie = Context::getContext()->cookie->__isset('psscan_tokenfc') ?
            Context::getContext()->cookie->__get('psscan_tokenfc') :
            null;
        $token = !empty($tokenParameter) ? $tokenParameter : $tokenCookie;

        return (empty($token) || $token != $tokenFC) ? false : true;
    }

    private function checkError()
    {
        // We can now check if there is an error returned by our
        if (Tools::getValue('error')) {
            
            // Exemple :
            // &error=access_denied
            // &error_description=The+resource+owner+or+authorization+server+denied+the+request.
            // &hint=The+user+denied+the+request
            // &message=The+resource+owner+or+authorization+server+denied+the+request.

            // @todo : Nicely display the error with a tpl
            // WARNING : Do not trust variables sent (to avoid XSS for example)
            echo Tools::getValue('error');
            echo Tools::getValue('error_description');
            echo Tools::getValue('hint');
            echo Tools::getValue('message');

            \PrestaScan\Tools::displayErrorAndDie(500);
            // end
        }
    }

    private function getTokenFc()
    {
        return \PrestaScan\Tools::getHashByName(
            "FCOauth",
            Configuration::get('PRESTASCAN_SEC_HASH')
        );
    }
}
