<?php
/**
 * Copyright 2023 Profileo Group <contact@profileo.com> (https://www.profileo.com/fr/)
 *
 * For questions or comments about this software, contact Maxime Morel-Bailly <security@prestascan.com>
 * List of required attribution notices and acknowledgements for third-party software can be found in the NOTICE file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author    Profileo Group - Complete list of authors and contributors to this software can be found in the AUTHORS file.
 * @copyright Since 2023 Profileo Group <contact@profileo.com> (https://www.profileo.com/fr/)
 * @license   https://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0
 */

namespace PrestaScan;

class VulnerabilityAlertHandler
{
    private $module;

    public function __construct(\Module $module)
    {
        $this->module = $module;
    }

    private function findModuleDisplayNameAndVersion($technicalName)
    {
        // Check if the version is concerned by the alert
        $moduleRawCacheFile = \PrestaScan\Tools::getModuleRawCacheFile();

        $version = null;
        $displayName = null;
        if (file_exists($moduleRawCacheFile)) {
            $modulesOnDiskCache = unserialize(file_get_contents($moduleRawCacheFile));
            // Note that the cache might be out of date. So the check might be done in a old version
            // Tho, we cannot refresh the scan (it's coming from a webhook and should be fast)
            // If the version if too old, we retrieve the version from the module instance (if possible)
            // Check if the cache is older than 15 days
            $cacheMaxAge = 15 * 24 * 60 * 60; // 15 days in seconds
            $currentTime = time();
            $fileModificationTime = filemtime($moduleRawCacheFile);
            $isCacheOld = ($currentTime - $fileModificationTime) > $cacheMaxAge;
            // Retrive the version
            foreach ($modulesOnDiskCache as $aModule) {
                try {
                    if ($aModule['name'] !== $alertModuleName) {
                        continue;
                    }
                    $version = $aModule['version'];
                    $displayName = $aModule['displayName'];
                    // However, if the cache is old, we try to retrieve the version from the module instance (if possible)
                    if ($isCacheOld) {
                        $obj = \Module::getInstanceByName($alertModuleName);
                        if ($obj && is_object($obj)) {
                            $version = $obj->version;
                            $displayName = $obj->displayName;
                        }
                    }
                    break;
                } catch (\Exception $exp) {
                    break;
                }
            }
        }

        if ($version === null) {
            // Cache file not existing OR issue retrieved the version, we try to get the version for the instance
            try {
                $obj = \Module::getInstanceByName($alertModuleName);
                if (is_object($obj)) {
                    $version = $obj->version;
                }
            } catch (\Exception $exp) {
                // Do nothing, we continue
            }
        }
    }

    public function handle($vulnerabilityData)
    {
        // Retrieve the module name
        $alertModuleName = $vulnerabilityData['name'];

        // Check if the module is present in the shop
        $modulePath = _PS_MODULE_DIR_ . $alertModuleName;
        $moduleFound = is_dir($modulePath);

        // The module is not in the shop
        if (!$moduleFound) {
            // Reply to the server to update the `confirmation_received` and `module_present_vulnerable` columns
            $data = [
                'confirmation_received' => true,
                'module_alerted' => false,
            ];
            return $data;
        }

        // Check if the version is concerned by the alert
        $moduleRawCacheFile = \PrestaScan\Tools::getModuleRawCacheFile();

        $version = null;
        if (file_exists($moduleRawCacheFile)) {
            $modulesOnDiskCache = unserialize(file_get_contents($moduleRawCacheFile));
            // Note that the cache might be out of date. So the check might be done in a old version
            // Tho, we cannot refresh the scan (it's coming from a webhook and should be fast)
            // If the version if too old, we retrieve the version from the module instance (if possible)
            // Check if the cache is older than 15 days
            $cacheMaxAge = 15 * 24 * 60 * 60; // 15 days in seconds
            $currentTime = time();
            $fileModificationTime = filemtime($moduleRawCacheFile);
            $isCacheOld = ($currentTime - $fileModificationTime) > $cacheMaxAge;
            // Retrive the version
            foreach ($modulesOnDiskCache as $aModule) {
                try {
                    if ($aModule['name'] !== $alertModuleName) {
                        continue;
                    }
                    $version = $aModule['version'];
                    // Hoever, if the cache is old, we try to retrieve the version from the module instance (if possible)
                    if ($isCacheOld) {
                        $obj = \Module::getInstanceByName($alertModuleName);
                        if (is_object($obj)) {
                            $version = $obj->version;
                        }
                    }
                    break;
                } catch (\Exception $exp) {
                    break;
                }
            }
        }

        if ($version === null) {
            // Cache file not existing OR issue retrieved the version, we try to get the version for the instance
            try {
                $obj = \Module::getInstanceByName($alertModuleName);
                if (is_object($obj)) {
                    $version = $obj->version;
                }
            } catch (\Exception $exp) {
                // Do nothing, we continue
            }
        }

        // Retrive the vulnerability versions
        $vulnerability = $vulnerabilityData['vulnerability'];

        $isAlerted = false;
        if ($version !== null) {
            $fromVersion = $vulnerability['from_version'];
            $toVersion = $vulnerability['to_version'];
            if (empty($fromVersion) && empty($toVersion)) {
                $isAlerted = true;
            } elseif (empty($fromVersion)) {
                // Compare $version to $toVersion
                if (\PrestaScan\Tools::versionCompareExtended($version, $toVersion) <= 0) {
                    $isAlerted = true;
                }
            } elseif (empty($toVersion)) {
                // Compare $version to $fromVersion
                if (\PrestaScan\Tools::versionCompareExtended($version, $fromVersion) >= 0) {
                    $isAlerted = true;
                }
            } else {
                // Compare $version to both $fromVersion and $toVersion
                if (\PrestaScan\Tools::versionCompareExtended($version, $fromVersion) >= 0
                    && \PrestaScan\Tools::versionCompareExtended($version, $toVersion) <= 0) {
                    $isAlerted = true;
                }
            }
        } else {
            // If null, we were not able to determine the version of the module, we consider it impacted anyway
            $isAlerted = true;
        }

        // Save the vulnerability alert to a new table in the database
        $alert = new \PrestaScanVulnAlerts();
        $saved = $alert->saveVulnerabilityAlert($alertModuleName, $vulnerability);

        // Reply to the server to update the `confirmation_received` and `module_present_vulnerable` columns
        $data = [
            'confirmation_received' => $saved,
            'module_alerted' => $isAlerted,
        ];

        return $data;
    }

    public function getNewVulnerabilityAlerts()
    {
        // Retrieve vulnerabilities not dismissed yet
        $results = \PrestaScanVulnAlerts::getAlertsNotDismissed();
        if (!$results) {
            return null;
        }

        // What's the current language of the employee?
        $defaultLanguage = isset($this->context) && isset($this->context->language) ?
            $this->context->language->iso_code :
            \Configuration::get('PS_LANG_DEFAULT');

        // Prepare alerts
        $alerts = array();

        // We need to retrieve the module real name
        $prestaShopModules = \Module::getModulesOnDisk(true);

        foreach ($results as $result) {
            foreach ($prestaShopModules as $k => $module) {
                if ($module->name != $result['module_name']) {
                    continue;
                }
                $result['name'] = $module->displayName;
                unset($prestaShopModules[$k]);
            }
            $vulnerabilityData = json_decode($result['vulnerability_data'], true);
            // We retrieve the description from the current context (when possible)
            $result['description'] = isset($vulnerabilityData[$defaultLanguage]) ?
                $vulnerabilityData[$defaultLanguage] :
                $vulnerabilityData['en'];

            // Criticity
            $criticity = strtolower($result['criticity']);
            $criticity = $criticity === 'critical' || $criticity === 'high' || $criticity === 'medium' || $criticity === 'low'
                ? $criticity
                : 'Unknown';
            $result['criticity'] = $criticity;

            // Type
            $result['vulnerability_type'] = $this->module->getVulnerabilityExtendedNameTranslated($result['vulnerability_type']);

            $alerts[] = $result;
        }
        return $alerts;
    }
}
